package genlogfields

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"

	logfields "github.com/improbable-io/go-proto-logfields"
)

func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Messages) == 0 {
		return nil // If there are no messages then we should not generate anything.
	}

	filename := file.GeneratedFilenamePrefix + ".logfields.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-gologfields. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	generateFileContent(gen, file, g)
	return g
}

var (
	fmtPkg       = protogen.GoImportPath("fmt")
	stringsPkg   = protogen.GoImportPath("strings")
	logfieldsPkg = protogen.GoImportPath("github.com/improbable-io/go-proto-logfields")
)

func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if !validateFileLogNames(gen, file) {
		return
	}

	for _, msg := range file.Messages {
		generateLogHandlers(g, msg)
		generateExtractRequestFields(g, msg)
	}
}

func validateFileLogNames(gen *protogen.Plugin, file *protogen.File) bool {
	isValid := true
	for _, msg := range file.Messages {
		isValid = isValid && validateMessageLogNames(gen, msg, nil, map[string]string{})
	}
	return isValid
}

func validateMessageLogNames(gen *protogen.Plugin, msg *protogen.Message, fieldStack []*protogen.Field, knownFieldNames map[string]string) bool {
	isValid := true

	for _, oneOf := range msg.Oneofs {
		oneOfFieldNames := map[string]string{}
		for _, field := range oneOf.Fields {
			fieldName, fieldLocation, ok := getFieldLogName(gen, field, fieldStack)
			if fieldName == "" {
				isValid = isValid && ok
				continue
			}

			if prevLocation, ok := knownFieldNames[fieldName]; ok {
				gen.Error(fmt.Errorf("log field name %q used at %q is already defined at %q", fieldName, prevLocation, fieldLocation))
				isValid = false
			} else {
				oneOfFieldNames[fieldName] = fieldLocation
			}
		}

		for k, v := range oneOfFieldNames {
			knownFieldNames[k] = v
		}
	}

	for _, field := range msg.Fields {
		if field.Oneof != nil {
			continue
		}

		if field.Message == nil || field.Desc.Cardinality() == protoreflect.Repeated {
			fieldName, fieldLocation, ok := getFieldLogName(gen, field, fieldStack)
			if fieldName == "" {
				isValid = isValid && ok
			} else if prevLocation, ok := knownFieldNames[fieldName]; ok {
				gen.Error(fmt.Errorf("log field name %q used at %q is already defined at %q", fieldName, prevLocation, fieldLocation))
				isValid = false
			} else {
				knownFieldNames[fieldName] = fieldLocation
			}
			continue
		}

		log, ok := retrieveLogAnnotation(field.Desc.Options())
		if !ok {
			gen.Error(extractionError(field.Desc.FullName()))
			isValid = false
			continue
		}

		if log.GetName() != "" {
			gen.Error(fmt.Errorf("cannot assign log name to message field %q, use a 'prefix' annotation if required", field.Desc.FullName()))
			isValid = false
			continue
		} else if log != nil && log.GetPrefix() == "" {
			gen.Error(fmt.Errorf("message field %q has an empty log prefix", field.Desc.FullName()))
			isValid = false
			continue
		}

		isValid = isValid && validateMessageLogNames(gen, field.Message, append(fieldStack, field), knownFieldNames)
	}
	return isValid
}

func getFieldLogName(gen *protogen.Plugin, field *protogen.Field, fieldStack []*protogen.Field) (string, string, bool) {
	log, ok := retrieveLogAnnotation(field.Desc.Options())
	if !ok {
		gen.Error(extractionError(field.Desc.FullName()))
		return "", "", false
	} else if log == nil {
		return "", "", true
	}

	if field.Desc.Cardinality() == protoreflect.Repeated {
		gen.Error(fmt.Errorf("cannot log repeated field %q", field.Desc.FullName()))
		return "", "", false
	}

	if log.GetName() == "" {
		gen.Error(fmt.Errorf("literal field %q has an empty log name", field.Desc.FullName()))
		return "", "", false
	} else if log.GetPrefix() != "" {
		gen.Error(fmt.Errorf(
			"literal field %q cannot have a log 'prefix' annotation, these are for nested message fields and one-ofs", field.Desc.FullName(),
		))
		return "", "", false
	}

	return fieldPrefix(fieldStack) + log.GetName(), fieldLocation(append(fieldStack, field)), true
}

func generateLogHandlers(g *protogen.GeneratedFile, msg *protogen.Message) {
	for _, childMsg := range msg.Messages {
		if !childMsg.Desc.IsMapEntry() {
			generateLogHandlers(g, childMsg)
		}
	}

	g.P("func (m *", msg.GoIdent, ") LogFields() map[string]string {")
	defer func() {
		g.P("}")
		g.P()
	}()

	var (
		complexMessageOrType bool = len(msg.Oneofs) > 0
		needsBody            bool
	)
	for _, field := range msg.Fields {
		if field.Desc.Cardinality() == protoreflect.Repeated {
			continue
		}

		if field.Desc.Kind() == protoreflect.MessageKind {
			complexMessageOrType = true
			needsBody = true
		} else if log, _ := retrieveLogAnnotation(field.Desc.Options()); log != nil {
			needsBody = true
		}
	}

	if !needsBody {
		g.P("return map[string]string{}")
		return
	}

	g.P("// Handle being called on nil message.")
	g.P("if m == nil {")
	g.P("return map[string]string{}")
	g.P("}")
	g.P()

	if !complexMessageOrType {
		literalsMapVar := generateLogHandlerLiteralsMap(g, msg)
		g.P("return ", literalsMapVar)
	} else {
		generateLogHandlerComplex(g, msg)
	}
}

func generateLogHandlerComplex(g *protogen.GeneratedFile, msg *protogen.Message) {
	g.P("// Gather fields from oneofs and child messages.")
	g.P("var hasInner bool")
	g.P()

	type mergeMap struct {
		mapVar string
		prefix string
	}
	var mapsToMerge []mergeMap

	for _, oneOf := range msg.Oneofs {
		oneOfMapVar := generateLogHandlerOneOfMap(g, oneOf)
		g.P("hasInner = hasInner || len(", oneOfMapVar, ") > 0")
		g.P()

		log, _ := retrieveLogAnnotation(oneOf.Desc.Options())
		mapsToMerge = append(mapsToMerge, mergeMap{
			mapVar: oneOfMapVar,
			prefix: log.GetPrefix(),
		})
	}

	for _, field := range msg.Fields {
		// Only handle fields containing nested messages.
		if field.Message == nil || field.Oneof != nil || field.Desc.Cardinality() == protoreflect.Repeated {
			continue
		}

		childMsgMapVar := "childMsgMap" + field.GoName
		g.P(childMsgMapVar, " := ", logfieldsPkg.Ident("ExtractLogFieldsFromMessage"), "(m.", field.GoName, ")")
		g.P("hasInner = hasInner || len(", childMsgMapVar, ") > 0")
		g.P()

		log, _ := retrieveLogAnnotation(field.Desc.Options())
		mapsToMerge = append(mapsToMerge, mergeMap{
			mapVar: childMsgMapVar,
			prefix: log.GetPrefix(),
		})
	}

	literalsMapVar := generateLogHandlerLiteralsMap(g, msg)

	// If there are no complex field maps to merge than we can return early.
	g.P("if !hasInner {")
	g.P("return ", literalsMapVar)
	g.P("}")
	g.P("")

	for _, mapToMerge := range mapsToMerge {
		g.P("for k, v := range ", mapToMerge.mapVar, " {")
		if mapToMerge.prefix != "" {
			g.P(literalsMapVar, `["`, mapToMerge.prefix, `."+k] = v`)
		} else {
			g.P(literalsMapVar, "[k] = v")
		}
		g.P("}")
		g.P()
	}
	g.P("return ", literalsMapVar)
}

func generateLogHandlerLiteralsMap(g *protogen.GeneratedFile, msg *protogen.Message) string {
	const literalsMapVar = "literalsMap"

	g.P(literalsMapVar, " := map[string]string{")
	for _, field := range msg.Fields {
		if field.Message != nil || field.Oneof != nil {
			continue
		}

		log, _ := retrieveLogAnnotation(field.Desc.Options())
		if log == nil {
			continue
		}
		// NB: See the comment on the 'fieldValue' on why this is so elaborate.
		g.P(append(append([]interface{}{`"`, log.GetName(), `": `}, fieldValue("m", field)...), ",")...)
	}
	g.P("}")
	g.P()

	return literalsMapVar
}

func generateLogHandlerOneOfMap(g *protogen.GeneratedFile, oneOf *protogen.Oneof) string {
	var oneOfMapVar = "oneOfMap" + oneOf.GoName

	g.P("var ", oneOfMapVar, " map[string]string")
	g.P("switch m.", oneOf.GoName, ".(type) {")
	for _, field := range oneOf.Fields {
		log, _ := retrieveLogAnnotation(field.Desc.Options())
		if log == nil && field.Message == nil {
			continue
		}

		g.P("case *", field.GoIdent, ":")
		if field.Message != nil {
			fieldRef := fmt.Sprintf("m.%s.(*%s).%s", oneOf.GoName, field.GoIdent.GoName, field.GoName)
			if log.GetPrefix() != "" {
				g.P(oneOfMapVar, " = map[string]string{}")
				g.P("for k, v := range ", logfieldsPkg.Ident("ExtractLogFieldsFromMessage"), "(", fieldRef, ") {")
				g.P(oneOfMapVar, `["`, log.GetPrefix(), `."+k] = v`)
				g.P("}")
			} else {
				g.P(oneOfMapVar, " = ", logfieldsPkg.Ident("ExtractLogFieldsFromMessage"), "(", fieldRef, ")")
			}
		} else {
			// NB: See the comment on the 'fieldValue' on why this is so elaborate.
			g.P(append(append([]interface{}{oneOfMapVar, ` = map[string]string{"`, log.GetName(), `": `}, fieldValue("m", field)...), "}")...)
		}
	}
	g.P("default:")
	g.P(oneOfMapVar, " = map[string]string{}")
	g.P("}")

	return oneOfMapVar
}

func generateExtractRequestFields(g *protogen.GeneratedFile, msg *protogen.Message) {
	for _, childMsg := range msg.Messages {
		if !childMsg.Desc.IsMapEntry() {
			generateExtractRequestFields(g, childMsg)
		}
	}

	g.P("func (m *", msg.GoIdent, ") ExtractRequestFields(prefixes []string, dst map[string]interface{}) {")
	defer func() {
		g.P("}")
		g.P()
	}()

	g.P("// Handle being called on nil message.")
	g.P("if m == nil {")
	g.P("return")
	g.P("}")

	for _, field := range msg.Fields {
		if field.Desc.Cardinality() == protoreflect.Repeated {
			continue
		}

		log, _ := retrieveLogAnnotation(field.Desc.Options())
		if field.Message == nil && log == nil {
			continue
		}

		g.P()
		if field.Oneof != nil {
			g.P("if _, ok := m.", field.Oneof.GoName, ".(*", field.GoIdent, "); ok {")
		}

		if field.Message != nil {
			prefixesVar := "prefixes"
			if log.GetPrefix() != "" {
				prefixesVar = fmt.Sprintf(`append(prefixes, "%s")`, log.GetPrefix())
			}
			g.P(logfieldsPkg.Ident("ExtractRequestFieldsFromMessage"), "(m.Get", field.GoName, "(), ", prefixesVar, ", dst)")
		} else if log != nil {
			g.P("dst[", stringsPkg.Ident("Join"), `(append(prefixes, "`, log.GetName(), `"), ".")] = m.Get`, field.GoName, "()")
		}

		if field.Oneof != nil {
			g.P("}")
		}
	}
}

func fieldLocation(fieldStack []*protogen.Field) string {
	var location string
	for idx, field := range fieldStack {
		if idx == 0 {
			location += string(field.Desc.FullName()) + "."
		} else {
			location += string(field.Desc.FullName().Name()) + "."
		}
	}
	return strings.TrimSuffix(location, ".")
}

func fieldPrefix(fieldStack []*protogen.Field) string {
	var prefix string
	for _, field := range fieldStack {
		if log, _ := retrieveLogAnnotation(field.Desc.Options()); log != nil {
			prefix += log.GetPrefix() + "."
		}
	}
	return prefix
}

// fieldValue produces a slice that should be fed directly into the generated file's printer method
// `g.P()`. We can not return a string as that would lead the 'GoImportPath.Ident()' method not to
// be handled approriately, producing invalid code and missing import declarations.
func fieldValue(parentStructVar string, field *protogen.Field) []interface{} {
	valueExpr := []interface{}{parentStructVar, ".Get", field.GoName, "()"}
	switch field.Desc.Kind() {
	case protoreflect.StringKind:
		// No special casing required.
	case protoreflect.BytesKind:
		valueExpr = append([]interface{}{"string("}, valueExpr...)
		valueExpr = append(valueExpr, ")")
	default:
		valueExpr = append([]interface{}{fmtPkg.Ident("Sprintf"), `("%v", `}, valueExpr...)
		valueExpr = append(valueExpr, ")")
	}
	return valueExpr
}

func extractionError(fieldName protoreflect.FullName) error {
	return fmt.Errorf("failed to extract log field annotation for field %q", fieldName)
}

func retrieveLogAnnotation(fieldOptions protoreflect.ProtoMessage) (*logfields.LogField, bool) {
	// The supplied interface might be empty but will still not be comparible to a nil pointer.
	// Hence we assert that the proto message is atleast valid before trying to extract our
	// extension field.
	if !fieldOptions.ProtoReflect().IsValid() {
		return nil, true
	}

	if proto.HasExtension(fieldOptions, logfields.E_Logfield) {
		logExt, ok := proto.GetExtension(fieldOptions, logfields.E_Logfield).(*logfields.LogField)
		if !ok {
			return nil, false
		}
		return logExt, true
	}
	return nil, true
}
